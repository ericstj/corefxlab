namespace System.Numerics
{
    public static partial class Tensor
    {
        public static System.Numerics.Tensor<T> Add<T>(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static void Add<T>(System.Numerics.Tensor<T> tensor, T scalar, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> Add<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static void Add<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> And<T>(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static void And<T>(System.Numerics.Tensor<T> tensor, T scalar, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> And<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static void And<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> Contract<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, int[] leftAxes, int[] rightAxes) { throw null; }
        public static void Contract<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, int[] leftAxes, int[] rightAxes, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> Decrement<T>(System.Numerics.Tensor<T> tensor) { throw null; }
        public static void Decrement<T>(System.Numerics.Tensor<T> tensor, System.Numerics.Tensor<T> result) { }
        public static void DecrementInPlace<T>(System.Numerics.Tensor<T> tensor) { }
        public static System.Numerics.Tensor<T> Divide<T>(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static void Divide<T>(System.Numerics.Tensor<T> tensor, T scalar, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> Divide<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static void Divide<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<bool> Equals<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static void Equals<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, System.Numerics.Tensor<bool> result) { }
        public static System.Numerics.Tensor<bool> GreaterThan<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static void GreaterThan<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, System.Numerics.Tensor<bool> result) { }
        public static System.Numerics.Tensor<bool> GreaterThanOrEqual<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static void GreaterThanOrEqual<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, System.Numerics.Tensor<bool> result) { }
        public static System.Numerics.Tensor<T> Increment<T>(System.Numerics.Tensor<T> tensor) { throw null; }
        public static void Increment<T>(System.Numerics.Tensor<T> tensor, System.Numerics.Tensor<T> result) { }
        public static void IncrementInPlace<T>(System.Numerics.Tensor<T> tensor) { }
        public static System.Numerics.Tensor<T> LeftShift<T>(System.Numerics.Tensor<T> tensor, int value) { throw null; }
        public static void LeftShift<T>(System.Numerics.Tensor<T> tensor, int value, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<bool> LessThan<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static void LessThan<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, System.Numerics.Tensor<bool> result) { }
        public static System.Numerics.Tensor<bool> LessThanOrEqual<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static void LessThanOrEqual<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, System.Numerics.Tensor<bool> result) { }
        public static System.Numerics.Tensor<T> Modulo<T>(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static void Modulo<T>(System.Numerics.Tensor<T> tensor, T scalar, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> Modulo<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static void Modulo<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> Multiply<T>(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static void Multiply<T>(System.Numerics.Tensor<T> tensor, T scalar, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> Multiply<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static void Multiply<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<bool> NotEquals<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static void NotEquals<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, System.Numerics.Tensor<bool> result) { }
        public static System.Numerics.Tensor<T> Or<T>(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static void Or<T>(System.Numerics.Tensor<T> tensor, T scalar, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> Or<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static void Or<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> RightShift<T>(System.Numerics.Tensor<T> tensor, int value) { throw null; }
        public static void RightShift<T>(System.Numerics.Tensor<T> tensor, int value, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> Subtract<T>(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static void Subtract<T>(System.Numerics.Tensor<T> tensor, T scalar, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> Subtract<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static void Subtract<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> UnaryMinus<T>(System.Numerics.Tensor<T> tensor) { throw null; }
        public static void UnaryMinus<T>(System.Numerics.Tensor<T> tensor, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> UnaryPlus<T>(System.Numerics.Tensor<T> tensor) { throw null; }
        public static void UnaryPlus<T>(System.Numerics.Tensor<T> tensor, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> Xor<T>(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static void Xor<T>(System.Numerics.Tensor<T> tensor, T scalar, System.Numerics.Tensor<T> result) { }
        public static System.Numerics.Tensor<T> Xor<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static void Xor<T>(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right, System.Numerics.Tensor<T> result) { }
    }


    public abstract partial class Tensor<T> : System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable
    {
        public Tensor(params int[] dimensions) { throw null; }
        public System.Collections.Generic.IReadOnlyList<int> Dimensions { get { throw null; } }
        public bool IsFixedSize { get { throw null; } }
        public bool IsReadOnly { get { throw null; } }
        public abstract T this[int index] { get; set; }
        public abstract T this[int indexRow, int indexColumn] { get; set; }
        public abstract T this[params int[] indices] { get; set; }
        public int Length { get { throw null; } }
        public int Rank { get { throw null; } }
        public abstract System.Numerics.Tensor<T> Clone();
        public abstract System.Numerics.Tensor<T> CloneEmpty();
        public abstract System.Numerics.Tensor<TResult> CloneEmpty<TResult>();
        
        public virtual void Fill(T value) { }
        public virtual System.Numerics.Tensor<T> GetDiagonal() { throw null; }
        public virtual System.Numerics.Tensor<T> GetDiagonal(int offset) { throw null; }
        public virtual System.Numerics.Tensor<T> GetTriangle() { throw null; }
        public virtual System.Numerics.Tensor<T> GetTriangle(int offset) { throw null; }
        public virtual System.Numerics.Tensor<T> GetUpperTriangle() { throw null; }
        public virtual System.Numerics.Tensor<T> GetUpperTriangle(int offset) { throw null; }
        public virtual System.Numerics.Tensor<T> Reshape(params int[] dimensions) { throw null; }

        #region comparison
        public static int Compare(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static bool Equals(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }

        public override bool Equals(object obj) { throw null; }
        public override int GetHashCode() { throw null; }
        #endregion

        #region operators
        public static System.Numerics.Tensor<T> operator +(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static System.Numerics.Tensor<T> operator +(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static System.Numerics.Tensor<T> operator &(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static System.Numerics.Tensor<T> operator &(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static System.Numerics.Tensor<T> operator |(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static System.Numerics.Tensor<T> operator |(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static System.Numerics.Tensor<T> operator --(System.Numerics.Tensor<T> tensor) { throw null; }
        public static System.Numerics.Tensor<T> operator /(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static System.Numerics.Tensor<T> operator /(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static System.Numerics.Tensor<T> operator ^(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static System.Numerics.Tensor<T> operator ^(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static System.Numerics.Tensor<T> operator ++(System.Numerics.Tensor<T> tensor) { throw null; }
        public static System.Numerics.Tensor<T> operator <<(System.Numerics.Tensor<T> tensor, int value) { throw null; }
        public static System.Numerics.Tensor<T> operator %(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static System.Numerics.Tensor<T> operator %(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static System.Numerics.Tensor<T> operator *(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static System.Numerics.Tensor<T> operator *(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static System.Numerics.Tensor<T> operator >>(System.Numerics.Tensor<T> tensor, int value) { throw null; }
        public static System.Numerics.Tensor<T> operator -(System.Numerics.Tensor<T> tensor, T scalar) { throw null; }
        public static System.Numerics.Tensor<T> operator -(System.Numerics.Tensor<T> left, System.Numerics.Tensor<T> right) { throw null; }
        public static System.Numerics.Tensor<T> operator -(System.Numerics.Tensor<T> tensor) { throw null; }
        public static System.Numerics.Tensor<T> operator +(System.Numerics.Tensor<T> tensor) { throw null; }
        #endregion

        #region other math
        public System.Numerics.Tensor<T> Contract(System.Numerics.Tensor<T> right, int[] axes, int[] rightAxes) { throw null; }
        public System.Numerics.Tensor<T> MatrixMultiply(System.Numerics.Tensor<T> right) { throw null; }
        #endregion

        #region interfaces
        void System.Collections.ICollection.CopyTo(System.Array array, int index) { }
        int System.Collections.ICollection.Count { get { throw null; } }
        bool System.Collections.ICollection.IsSynchronized { get { throw null; } }
        object System.Collections.ICollection.SyncRoot { get { throw null; } }
        public System.Collections.IEnumerator GetEnumerator() { throw null; }
        object System.Collections.IList.this[int index] { get { throw null; } set { } }
        int System.Collections.IList.Add(object value) { throw null; }
        void System.Collections.IList.Clear() { }
        bool System.Collections.IList.Contains(object value) { throw null; }
        int System.Collections.IList.IndexOf(object value) { throw null; }
        void System.Collections.IList.Insert(int index, object value) { }
        void System.Collections.IList.Remove(object value) { }
        void System.Collections.IList.RemoveAt(int index) { }
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer) { throw null; }
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer) { throw null; }
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer) { throw null; }
        #endregion
    }

    public static partial class DenseTensor
    {
        public static DenseTensor<T> CreateFromDiagonal<T>(System.Numerics.Tensor<T> diagonal) { throw null; }
        public static DenseTensor<T> CreateFromDiagonal<T>(System.Numerics.Tensor<T> diagonal, int offset) { throw null; }
        public static DenseTensor<T> CreateIdentity<T>(int size) { throw null; }
        public static DenseTensor<T> CreateIdentity<T>(int size, bool columMajor) { throw null; }
        public static DenseTensor<T> CreateIdentity<T>(int size, bool columMajor, T oneValue) { throw null; }

        public static DenseTensor<T> FromArray<T>(T[] array) { throw null; }
        public static DenseTensor<T> FromArray<T>(T[,] array) { throw null; }
        public static DenseTensor<T> FromArray<T>(T[,,] array) { throw null; }
        public static DenseTensor<T> FromArray<T>(Array array) { throw null; }
        public static DenseTensor<T> FromArray<T>(T[] array, bool columnMajor) { throw null; }
        public static DenseTensor<T> FromArray<T>(T[,] array, bool columnMajor) { throw null; }
        public static DenseTensor<T> FromArray<T>(T[,,] array, bool columnMajor) { throw null; }
        public static DenseTensor<T> FromArray<T>(Array array, bool columnMajor) { throw null; }


        public static DenseTensor<T> OverBuffer<T>(Buffer<T> buffer, params int[] dimensions) { throw null; }
        public static DenseTensor<T> OverBuffer<T>(Buffer<T> buffer, bool columnMajor, params int[] dimensions) { throw null; }
        public static DenseTensor<T> OverArray<T>(T[] array, params int[] dimensions) { throw null; }
        public static DenseTensor<T> OverArray<T>(T[] array, bool columnMajor, params int[] dimensions) { throw null; }

    }

    public partial class DenseTensor<T> : Tensor<T>
    {
        public DenseTensor(params int[] dimensions) : base(dimensions) { }
        public DenseTensor(bool columnMajor, params int[] dimensions) : base(dimensions) { }

        public DenseTensor(Buffer<T> buffer, params int[] dimensions) : base(dimensions) { }
        public DenseTensor(Buffer<T> buffer, bool columnMajor, params int[] dimensions) : base(dimensions) { }

        public override T this[int index] { get => throw null; set => throw null; }
        public override T this[params int[] indices] { get => throw null; set => throw null; }
        public override T this[int indexRow, int indexColumn] { get => throw null; set => throw null; }

        public Buffer<T> Buffer { get { throw null; } }
        public bool IsColumnMajor { get { throw null; } }
        public bool IsRowMajor { get { throw null; } }

        public override Tensor<T> Clone() { throw null; }

        public override Tensor<T> CloneEmpty() { throw null; }

        public override Tensor<TResult> CloneEmpty<TResult>() { throw null; }
    }

    public static partial class SparseTensor
    {
        public static SparseTensor<T> FromTensor<T>(Tensor<T> tensor) { throw null; }
        public static SparseTensor<T> FromTensor<T>(Tensor<T> tensor, bool compressColumn) { throw null; }
    }

    public partial class SparseTensor<T> : Tensor<T>
    {
        public SparseTensor(params int[] dimensions) : base(dimensions) { }
        public SparseTensor(int initialCapacity, params int[] dimensions) : base(dimensions) { }


        public override T this[int index] { get => throw null; set => throw null; }
        public override T this[params int[] indices] { get => throw null; set => throw null; }
        public override T this[int indexRow, int indexColumn] { get => throw null; set => throw null; }
        public override Tensor<T> Clone() { throw null; }

        public override Tensor<T> CloneEmpty() { throw null; }

        public override Tensor<TResult> CloneEmpty<TResult>() { throw null; }

        public DenseTensor<T> ToDenseTensor() { throw null; }
    }

    public static partial class CompressedSparseTensor
    {
        public static CompressedSparseTensor<T> FromTensor<T>(Tensor<T> tensor) { throw null; }
        public static CompressedSparseTensor<T> FromTensor<T>(Tensor<T> tensor, bool compressColumn) { throw null; }
        public static CompressedSparseTensor<T> FromSparseTensor<T>(SparseTensor<T> tensor) { throw null; }
        public static CompressedSparseTensor<T> FromSparseTensor<T>(SparseTensor<T> tensor, bool compressColumn) { throw null; }

        public static CompressedSparseTensor<T> OverCompressedSparseRows<T>(T[] values, int[] rowCounts, int[] remainingIndices, params int[] dimensions) { throw null; }
        public static CompressedSparseTensor<T> OverCompressedSparseColumns<T>(T[] values, int[] columnCounts, int[] remainingIndices, params int[] dimensions) { throw null; }
    }

    public partial class CompressedSparseTensor<T> : Tensor<T>
    {
        public CompressedSparseTensor(T[] values, int[] compressedCounts, int[] remainingIndices, params int[] dimensions) : base(dimensions) { }
        public CompressedSparseTensor(T[] values, int[] compressedCounts, int[] remainingIndices, bool compressColumn, params int[] dimensions) : base(dimensions) { }

        public T[] Values { get { throw null; } }
        public int[] CompressedCounts { get { throw null; } }
        public int[] RemainingIndices { get { throw null; } }

        public bool CompressedColumn { get { throw null; } }

        public DenseTensor<T> ToDenseTensor() { throw null; }
        public DenseTensor<T> ToSparseTensor() { throw null; }

        public override T this[int index] { get => throw null; set => throw null; }
        public override T this[params int[] indices] { get => throw null; set => throw null; }
        public override T this[int indexRow, int indexColumn] { get => throw null; set => throw null; }
        public override Tensor<T> Clone() { throw null; }

        public override Tensor<T> CloneEmpty() { throw null; }

        public override Tensor<TResult> CloneEmpty<TResult>() { throw null; }
    }
}
